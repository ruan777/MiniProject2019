#include <idc.idc>

/*
define some hex string:
-ssl/pqueue.c
-Assertion failed: item != NULL
-item != NULL
*/

#define HEX_SSL_PQUEUE_C "73 73 6C 2F 70 71 75 65 75 65 2E 63 00" 
#define HEX_ASSERT_FAIL  "41 73 73 65 72 74 69 6F 6E 20 66 61 69 6C 65 64 3A 20 69 74 65 6D 20 21 3D 20 4E 55 4C 4C 00"
#define HEX_ITEM_NULL    "69 74 65 6D 20 21 3D 20 4E 55 4C 4C 00"


extern Funcs;

static main(){
    Funcs = GetAllFunc(); //return an array contain all func's addr
    auto pqueue_find = GetFuncAddr(Funcs,"_pqueue_find");
    auto pqueue_insert = GetFuncAddr(Funcs,"_pqueue_insert");
    
    if(pqueue_find == -1 || pqueue_insert == -1){
        pqueue_insert = Locate_pqueue_insert();
        auto t = get_next_func(pqueue_insert); //pqueue_peek
        t = get_next_func(t);   //pqueue_pop
        pqueue_find = get_next_func(t); //pqueue_find :)
    }
    
    auto id_pqueue_find = Get_xrefs(pqueue_find,"xrefs_of_pqueue_find");
    auto id_pqueue_insert = Get_xrefs(pqueue_insert,"xrefs_of_pqueue_insert");
    
    auto dtls1_reassemble_fragment = Search_equal_element(id_pqueue_find,id_pqueue_insert);
    auto dtls1_process_out_of_seq_message = get_next_func(dtls1_reassemble_fragment);
    
    auto str_itemnull = find_binary(0,SEARCH_DOWN,HEX_ITEM_NULL);
    auto str_assert_fail = find_binary(0,SEARCH_DOWN,HEX_ASSERT_FAIL);
    auto assert_fail_dref = Get_drefs(str_assert_fail,"Assertion failed: item != NULL");
    auto itemnull_dref = Get_drefs(str_itemnull,"item != NULL");

    if(str_assert_fail != -1 || str_itemnull != -1){
    
        if(( Find_element(itemnull_dref,dtls1_reassemble_fragment) != -1 ||
             Find_element(assert_fail_dref,dtls1_reassemble_fragment) != -1) &&
             ( Find_element(itemnull_dref,dtls1_process_out_of_seq_message) != -1 ||
                 Find_element(assert_fail_dref,dtls1_process_out_of_seq_message) != -1 ))
            Warning("CVE-2014-3507 fixed! :)");
        else
            Warning("CVE-2014-3507 not fixed! :("); 
    }
    else{
        Warning("CVE-2014-3507 not fixed! :(");	
    }
}
//find all xrefs of func
static Get_xrefs(func_addr,array_name){
    auto id = get_array_id(array_name);
    if(id != -1)
        delete_array(id);
    id = create_array(array_name);
      
    auto addr;
    auto idx = 0;
    auto func_start = 0;
    for(addr = get_first_cref_to(func_addr); addr != BADADDR; addr = get_next_cref_to(func_addr,addr)){
        func_start = get_func_attr(addr,FUNCATTR_START);
        set_array_long(id,idx,func_start);
        idx = idx + 1;
    }
    return id;
}

//find all dref of string
static Get_drefs(str_addr,array_name){
    auto id = get_array_id(array_name);
    if(id != -1)
        delete_array(id);
    id = create_array(array_name);
      
    auto addr;
    auto idx = 0;
    auto func_start = 0;
    for(addr = get_first_dref_to(str_addr); addr != BADADDR; addr = get_next_dref_to(str_addr,addr)){
        func_start = get_func_attr(addr,FUNCATTR_START);
        set_array_long(id,idx,func_start);
        idx = idx + 1;
    }
    return id;
}


static GetFuncAddr(id,func_name){
    auto addr = LocByName(func_name);
    if(addr != BADADDR)
        return addr;
    auto idx = 0;
    for( idx = get_first_index(AR_LONG,id);idx != -1;idx= get_next_index(AR_LONG,id,idx)){
        addr = get_array_element(AR_LONG,id,idx);
        if(Name(addr) == func_name)
            return addr;
    }
    return -1;
}

static GetAllFunc(void){
    auto id = get_array_id("Funcs");
    if(id != -1)
        delete_array(id);
    id = create_array("Funcs");
    if(id == -1){
        Warning("Can't create array!");
        return -1;
    }
    
    auto idx = 0;
    auto ea;
    for(ea = get_next_func(0); ea != BADADDR; ea = get_next_func(ea)){
        set_array_long(id,idx,ea);
        idx = idx + 1;
    }
    return id;
}

static Show(id){
    auto idx = 0;
    for( idx = get_first_index(AR_LONG,id);idx != -1;idx= get_next_index(AR_LONG,id,idx)){
        Message("idx%d : 0x%X\n",idx,get_array_element(AR_LONG,id,idx));
    }
}

static Search_equal_element(id1,id2){
    auto idx1 = 0;
    auto idx2 = 0;
    auto v1 = 0;
    for( idx1 = GetFirstIndex(AR_LONG,id1); idx1 != -1; idx1 = GetNextIndex(AR_LONG,id1,idx1)){
        
        v1 = GetArrayElement(AR_LONG,id1,idx1);
        
        for( idx2 = GetFirstIndex(AR_LONG,id2); idx2 != -1; idx2 = GetNextIndex(AR_LONG,id2,idx2)){
            if(v1 == GetArrayElement(AR_LONG,id2,idx2)) //found!
                return v1;
        }
    }
    return -1;//not found
}

static Locate_pqueue_insert(void){
    //first we need to find pqueue_new
    //pqueue_new called crypto_zalloc and ref string "ssl/pqueue.c"
    //to search string "ssl/pqueue.c"
    auto str_addr = find_binary(0,SEARCH_DOWN,HEX_SSL_PQUEUE_C);
    auto xref_str = Get_drefs(str_addr,"pqueue.c");
    auto crypto_zalloc = GetFuncAddr(Funcs,"_CRYPTO_zalloc");
    auto xref_crypto_zalloc = Get_xrefs(crypto_zalloc,"crypto_zalloc");
    auto pqueue_new = Search_equal_element(xref_str,xref_crypto_zalloc);
    //Show(xref_str);
    //Message("0x%x\n",pqueue_new);
    
    auto t = get_next_func(pqueue_new); //pqueue_free,but we don't need it
    auto pqueue_insert = get_next_func(t);//get it :)
    
    return pqueue_insert;
}

//search position of value in an array
static Find_element(id,value){
    auto idx = 0;
    for( idx = GetFirstIndex(AR_LONG,id);idx != -1;idx= GetNextIndex(AR_LONG,id,idx))
            if(value == GetArrayElement(AR_LONG,id,idx))
                return idx;
    //not found 
    return -1;
}

