## 思路：根据diff
```c
--- a/ssl/d1_lib.c
+++ b/ssl/d1_lib.c
@@ -543,6 +543,9 @@ int dtls1_listen(SSL *s, struct sockaddr *client)
 {
     int ret;
 
+    /* Ensure there is no state left over from a previous invocation */
+    SSL_clear(s);
+
     SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);
     s->d1->listen = 1;
 ```
可知为了修复cve-2015-0207在**dtls1_listen**函数里调用了**SSL_clear**函数,根据这一特征,
 
想到了先定位**dtls1_listen**和**SSL_clear**函数的地址，在查看**SSL_clear**函数的交叉引用中有没有**dtls1_listen**函数来检测漏洞是否被修复
 
```c
int dtls1_listen(SSL *s, struct sockaddr *client)
{
    int ret;

    /* Ensure there is no state left over from a previous invocation */
    SSL_clear(s);

    SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);
    s->d1->listen = 1;

    ret = SSL_accept(s);
    if (ret <= 0)
        return ret;

    (void)BIO_dgram_get_peer(SSL_get_rbio(s), client);
    return 1;
}
```
**dtls1_listen**函数调用了**SSL_accept**和**SSL_get_rbio**，根据查找这两个函数的交叉引用，找到一个相同的地址，那个地址即为**dtls1_listen**函数的地址
